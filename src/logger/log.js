// logger.js
import fs from "fs";
import path from "path";
import os from "os";

let isLoggingEnabled = true;
let isLoggingPaused = false;
const logFiles = {};
const logLevels = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};
let currentLogLevel = logLevels.info;
let logContext = {};
let autoFunctionName = false;
let logDirectory = process.cwd(); // Default to current working directory

const defaultLogFormat = (level, date, message) => {
  return `[<span class="math-inline">\{level\.toUpperCase\(\)\}\] \[</span>{date.toISOString()}] ${message}`;
};

let logFormat = defaultLogFormat;

const log = (functionName, level, ...args) => {
  if (!isLoggingEnabled || isLoggingPaused || !shouldLog(level)) {
    return;
  }

  const actualFunctionName =
    functionName || (autoFunctionName ? getCallingFunctionName() : "general");
  let logFilePath = logFiles[actualFunctionName];

  if (!logFilePath) {
    logFilePath = path.join(logDirectory, `wow-js-${actualFunctionName}.log`);
    logFiles[actualFunctionName] = logFilePath;

    try {
      const fileContent = fs.readFileSync(logFilePath, "utf8");
      if (!fileContent.includes("Generated by wow-js")) {
        fs.appendFile(logFilePath, `Generated by wow-js\n`, (err) => {
          if (err) {
            console.error(
              `Error initializing log file for ${actualFunctionName}: ${err}`
            );
          }
        });
      }
    } catch (err) {
      fs.appendFile(logFilePath, `Generated by wow-js\n`, (err) => {
        if (err) {
          console.error(
            `Error initializing log file for ${actualFunctionName}: ${err}`
          );
        }
      });
    }
  }

  const date = new Date();
  let formattedArgs = args.map((arg) => {
    if (typeof arg === "string") {
      return arg;
    } else {
      try {
        const jsonString = JSON.stringify(arg);
        return `<span class="math-inline">\{jsonString\} \(</span>{getDataInfo(arg)})`;
      } catch (e) {
        return `<span class="math-inline">\{String\(arg\)\} \(</span>{getDataInfo(arg)})`;
      }
    }
  });

  let formattedMessage = logFormat(level, date, formattedArgs.join(" "));

  if (logContext && Object.keys(logContext).length > 0) {
    formattedMessage += ` Context: ${JSON.stringify(logContext)}`;
  }

  let consoleOutput = false;
  if (
    args.length > 0 &&
    typeof args[args.length - 1] === "object" &&
    args[args.length - 1].consoleOutput === true
  ) {
    consoleOutput = true;
    args.pop();
  }

  if (consoleOutput) {
    console.log(formattedMessage);
  }

  fs.appendFile(
    logFilePath,
    formattedMessage +
      "\n" +
      "--------------------------------------------------\n",
    (err) => {
      if (err) {
        console.error(
          `Error writing to log file for ${actualFunctionName}: ${err}`
        );
      }
    }
  );
};

const pauseLogging = () => {
  isLoggingPaused = true;
};

const resumeLogging = () => {
  isLoggingPaused = false;
};

const disableLogging = () => {
  isLoggingEnabled = false;

  const makeReadOnly = (filePath) => {
    if (os.platform() === "win32") {
      fs.chmod(filePath, 0o444, (err) => {
        if (err) {
          console.error(`Error setting read-only for ${filePath}: ${err}`);
        }
      });
    } else {
      fs.chmod(filePath, 0o444, (err) => {
        if (err) {
          console.error(`Error setting read-only for ${filePath}: ${err}`);
        }
      });
    }
  };

  for (const functionName in logFiles) {
    if (logFiles.hasOwnProperty(functionName)) {
      const filePath = logFiles[functionName];
      makeReadOnly(filePath);
    }
  }

  Object.keys(logFiles).forEach((filename) => delete logFiles[filename]);
};

const getCallingFunctionName = () => {
  try {
    throw new Error();
  } catch (err) {
    if (err.stack) {
      const stackLines = err.stack.split("\n");
      if (stackLines.length > 3) {
        const callerLine = stackLines[3].trim();
        const functionNameMatch = callerLine.match(/at\s+([\w.<>]+)/);
        if (functionNameMatch && functionNameMatch[1]) {
          return functionNameMatch[1].split(".")[0];
        }
      }
    }
    return "unknown";
  }
};

const shouldLog = (level) => {
  return isLoggingEnabled && logLevels[level] >= currentLogLevel;
};

const writeLogHeading = (heading, functionName) => {
  const actualHeading = heading || "Log Heading";
  const actualFunctionName = functionName || "general";
  let logFilePath = logFiles[actualFunctionName];

  if (!logFilePath) {
    logFilePath = path.join(logDirectory, `wow-js-${actualFunctionName}.log`);
    logFiles[actualFunctionName] = logFilePath;
  }

  fs.appendFile(
    logFilePath,
    `\n================== ${actualHeading} ==================\n`,
    (err) => {
      if (err) {
        console.error(
          `Error writing log heading for ${actualFunctionName}: ${err}`
        );
      }
    }
  );
};

const timers = {};

const startTimer = (timerName) => {
  timers[timerName] = process.hrtime();
};

const stopTimer = (timerName, message) => {
  if (!timers[timerName]) {
    return;
  }
  const elapsed = process.hrtime(timers[timerName]);
  const elapsedMs = elapsed[0] * 1000 + elapsed[1] / 1000000;
  wowLog.info(`${message} took ${elapsedMs.toFixed(2)}ms`);
  delete timers[timerName];
};

const wowLog = {
  setLevel: (level) => {
    currentLogLevel = logLevels[level] || currentLogLevel;
  },
  format: (formatFunction) => {
    logFormat = formatFunction;
  },
  debug: (...args) => log(null, "debug", ...args),
  info: (...args) => log(null, "info", ...args),
  warn: (...args) => log(null, "warn", ...args),
  error: (...args) => log(null, "error", ...args),
  pause: pauseLogging,
  resume: resumeLogging,
  addContext: (data) => {
    logContext = data;
  },
  clearContext: () => {
    logContext = {};
  },
  disable: disableLogging,
  setAutoFunctionName: (enabled) => {
    if (enabled != true && enabled != false) {
      autoFunctionName = false;
      console.warn(
        "wowLog: You must pass a boolean value as argument else predefined settings is executed."
      );
      return;
    }
    autoFunctionName = enabled;
    if (enabled) {
      console.warn(
        "wowLog: Automatic function name collection is enabled. This feature has potential reliability and performance issues."
      );
    }
  },
};

export default wowLog;
